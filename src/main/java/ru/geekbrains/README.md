# Урок 1. Алгоритмы и структуры данных
1. Задание 1.1
Приведите пример алгоритмов и структур данных из жизни.
2. Задание 1.2
Приведите пример алгоритмов и структур данных в программировании.
3. Задание 1.3
Напишите программный код, в котором все данные хранятся только в переменных трех типов данных: Ссылочные, примитивные и своего класса содержащего: конструктор и метод отображения данных.
Выведите написанные данные.
4. Задание 1.4
Дополните предыдущий код сравнением ваших данных с другой переменной, данный код должен имитировать простейший поиск перебором.
Оцените время выполнения алгоритма с помощью базового метода System.nanoTime().
# Урок 2. Массивы и сортировка
1. Задание 2.1
На основе программного кода из домашнего задания №1 реализуйте массив на основе существующих примитивных или ссылочных типов данных.
Выполните обращение к массиву и базовые операции класса Arrays.
Оценить выполненные методы с помощью базового класса System.nanoTime().
2. Задание 2.2
На основе написанного кода в задании 2.1 реализуйте линейный и двоичный поиск.
Оценить алгоритмы линейного и двоичного поиска с помощью базового класса System.nanoTime(), при необходимости расширьте уже существующий массив данных.
3. Задание 2.3
Создайте массив размером 400 элементов.
Выполните сортировку с помощью метода sort().
Оцените сортировку с помощью базового класса System.nanoTime().
4. Задание 2.4
На основе существующего массива данных из задания 2.3 реализуйте алгоритм сортировки пузырьком.
Оцените сортировку с помощью базового класса System.nanoTime().
Сравните время выполнения алгоритмы сортировки методом sort() из задания 2.1 и сортировку пузырьком.
5. Задание 2.5
На основе массива данных из задания 2.3 реализуйте алгоритм сортировки методом выбора.
Оцените сортировку с помощью базового класса System.nanoTime().
Сравните с временем выполнения алгоритмов сортировки из прошлых заданий 2.3 и 2.4.
6. Задание 2.6
На основе массива данных из задания 2.3 реализуйте алгоритм сортировки методом вставки.
Оцените сортировку с помощью базового класса System.nanoTime().
Сравните с временем выполнения алгоритмов сортировки из прошлых заданий 2.3, 2.4 и 2.5.
# Урок 3. Коллекции, списки, связанные списки и итераторы
1. Задание 3.1
На основе массива из домашнего задания 2.1 реализуйте простой список и коллекцию.
Оцените время выполнения преобразования.
2. Задание 3.2
На основе списка из задания 3.1 реализуйте основные методы добавления, удаления и получения объекта или элемента из списка.
Оценить выполненные методы с помощью базового класса System.nanoTime().
3. Задание 3.3
Реализуйте простой односвязный список и его базовые методы.
4. Задание 3.4
На основе списка из задания 3.1 реализуйте простой двусторонний список и его базовые методы.
Реализуйте список заполненный объектами из вашего класса из задания 1.3
5. Задание 3.5
Реализуйте итератор на основе связанных списков из задания 3.4 и выполните базовые операции итератора.
Оцените время выполнения операций с помощью базового метода System.nanoTime()
# Урок 4. Стеки и очереди
1. Задание 4.1
На основе данных объектного списка из задания 3.4 реализуйте простой стек и его базовые методы.
Оцените время выполнения операций с помощью базового метода System.nanoTime().
2. Задание 4.2
На основе данных объектного списка из задания 3.4 реализуйте простую очередь и его базовые методы.
Реализуйте вспомогательные методы.
Оцените время выполнения операций с помощью базового метода System.nanoTime().
3. Задание 4.3
На основе данных объектного списка из задания 3.4 реализуйте простой дек и его базовые методы.
Оцените время выполнения операций с помощью базового метода System.nanoTime().
4. Задание 4.4
Реализуйте приоритетную очередь на основе ссылочных типов данных, например, integer.
Оцените время выполнения операций с помощью базового метода System.nanoTime().
5. Задание 4.5
На основе данных из задания 4.1 и 4.2, реализуйте стек и очередь на базе связанного списка.
Оцените время выполнения операций с помощью базового метода System.nanoTime().
# Урок 5. Рекурсия
1. Задание 5.1
Приведите пример использования рекурсии.
2. Задание 5.2
Реализуйте простой пример бесконечной рекурсии и обычной рекурсии с условием для выхода.
3. Задание 5.3
Приведите пример изображающий стек вызова и стек вызова с рекурсией.
4. Задание 5.4
Реализуйте простой алгоритм использующий цикл и простой алгоритм использующий рекурсию.
Оцените два алгоритма с помощью базового метода System.nanoTime().
5. Задание 5.5
Реализуйте алгоритм двоичного рекурсивного поиска на основе массива из задания 2.1.
Оцените алгоритм двоичного рекурсивного поиска с помощью базового метода System.nanoTime() и сравните с обычным двоичным поиском.
6. Задание 5.6
На основе массива из задания 2.1 реализуйте алгоритм сортировки слиянием.
Оцените алгоритм сортировки слиянием с помощью базового метода System.nanoTime() и сравните с сортировкой методом sort().
# Урок 6. Деревья
1. Задание 6.1
Приведите пример использования древовидной структуры.
2. Задание 6.2
Реализуйте класс узла дерева и базовый шаблон дерева с базовыми методами.
3. Задание 6.3
Реализуйте методы поиска и вставки узла в дерево.
4. Задание 6.4
Реализуйте базовые методы обхода дерева и метода дисплей.
Реализуйте поиск максимума и минимума.
5. Задание 6.5
Реализуйте метод удаления узла и выполните оценку времени базовых методов дерева с помощью System.nanoTime().
6. Задание 6.6
Реализуйте на основе массива из задания 2.1 алгоритм пирамидальной сортировки с реализацией бинарной пирамиды.
Выполните оценку алгоритма пирамидальной сортировки с помощью System.nanoTime() и сравните с предыдущими алгоритмами сортировки.
7. Задание 6.7
Приведите пример сбалансированного дерева и его применения.
# Урок 7. Графы
1. Задание 7.1
Приведите пример графа.
2. Задание 7.2
Реализуйте базовые методы графа.
3. Задание 7.3
В программный код из задания 7.2 добавьте реализацию метода обхода в глубину.
Выполните оценку времени с помощью System.nanoTime().
4. Задание 7.4
В базовом графе из задания 7.2 реализуйте метод обхода в ширину.
Выполните оценку времени с помощью System.nanoTime().
# Урок 8. Хеш-таблицы
1. Задание 8.1
Приведите пример использование хеш-таблиц.
2. Задание 8.2
Приведите примеры ключей и коллизий.
3. Задание 8.3
Приведите примеры популярных и эффективных хеш-функций.
4. Задание 8.4
На основе данных массива из задания 2.3 реализуйте хеш-таблицу с помощью открытой адресации, а конкретнее метода линейного пробирования
5. Задание 8.5
Перестройте программный код задания 8.4 из алгоритма линейного пробирования в алгоритм двойного хеширования.
Сравните отличительные черты двух алгоритмов.
